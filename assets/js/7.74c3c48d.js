(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{384:function(t,e,a){t.exports=a.p+"assets/img/5.6.1.0eea4785.png"},385:function(t,e,a){t.exports=a.p+"assets/img/5.6.2.d7a8ba76.png"},386:function(t,e,a){t.exports=a.p+"assets/img/5.6.3.7133690c.png"},387:function(t,e,a){t.exports=a.p+"assets/img/5.6.4.24bd2921.png"},502:function(t,e,a){"use strict";a.r(e);var s=a(25),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_6-vue源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue源码"}},[t._v("#")]),t._v(" 6.vue源码")]),t._v(" "),s("h2",{attrs:{id:"主要分为两个系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要分为两个系统"}},[t._v("#")]),t._v(" 主要分为两个系统")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("数据驱动，即数据系统，数据响应式。主要包括数据的劫持、发布订阅等，具体体现在Observer(数据劫持)、Dep(收集依赖，通知Watcher)、Watcher(订阅者，包括render-watcher、computed-watcher、normal-watcher)三个类；")])]),t._v(" "),s("li",[s("p",[t._v("组件化，即编译系统，虚拟DOM。主要包括模版解析、静态节点标记优化、生成可渲染的字符串，具体体现在paser(生成AST)、optimize(标记静态节点)、generate(生成渲染函数)三个方法。")])])]),t._v(" "),s("h2",{attrs:{id:"vue源码目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue源码目录"}},[t._v("#")]),t._v(" vue源码目录")]),t._v(" "),s("img",{attrs:{src:a(384)}}),t._v(" "),s("h2",{attrs:{id:"核心实现-响应式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心实现-响应式"}},[t._v("#")]),t._v(" 核心实现-响应式")]),t._v(" "),s("img",{attrs:{src:a(385)}}),t._v(" "),s("ol",[s("li",[t._v("创建Vue类，通过Observer劫持监听所有属性。")])]),t._v(" "),s("blockquote",[s("p",[t._v("observe函数的作用：递归遍历data选项，它当中的defineReactive函数为data中每一个key定义getter和setter，达到数据劫持的目的。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("ol",[s("li",[t._v("创建Dep类，将视图中的所有依赖收集管理，包括依赖添加和派发通知；")])])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("deps"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 存放Watcher的实例")]),t._v("\naddDep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 添加Watcher")]),t._v("\nnotify"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通知所有的Wather执行更新。遍历deps数组，调用每个Wather的更新方法")]),t._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("创建监听器Watcher类;")])])])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("收集：在created和beforeMounted之间生成了AST和render可执行函数，用到了compile的createCompiler生成对象结构的AST语法树，再通过generator调用了之前初始化的方法处理各种vue内置的方法&指令，如v-for v-if等，通过createElement、createTextVnode等生成虚拟DOM树，作为updateComponent函数返回。")])]),t._v(" "),s("li",[s("p",[t._v("渲染：在beforeMounted和mounted之间通过将执行这个函数，这个函数会将虚拟DOM渲染成真正的DOM，内含有patch的布丁算法，在执行过程中会触发渲染函数，这时会触发数据属性的get函数，而这个过程的观察者就是渲染函数，在渲染过程中添加数据的订阅者，watcher订阅者是Observer和Compiler之间的桥梁，将在自身实例化的时候将自己添加到dep当中，watcher自身有一个depend和update方法，待属性变动dep.notice通知调用自身的update方法触发Compile中绑定的回调。")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Dep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将当前Watcher实例添加到Dep.target上。get时，就能通过Dep.target拿到当前Watcher的实例。")]),t._v("\nupdate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用dep.notify，让依赖管理器通知更新，则所有的Watcher会执行update方法")]),t._v("\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[s("p",[t._v("创建compile.js，用于扫描模板中所有依赖(指令、插值、绑定、事件…)，创建更新函数和Watcher；")])]),t._v(" "),s("li",[s("ol",[s("li",[t._v("创建编译器Compile类，接收两个参数，el(宿主元素或选择器)和vm(当前vue实例);")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("创建node2Fragment函数，将dom节点( $el )截成代码块( 转换为Fragment )来处理，而不是直接做dom操作，提高执行效率。")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("创建一个新的fragment，将原生节点移动至fragment;\n返回fragment，传给编译函数进行编译；")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("创建compile函数，执行编译( 将模板中的动态值替换为真实的值 )，传入代码块;")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("获取所有的孩子节点，进行遍历，判断节点类型，并作出相应的判断;\n处理元素节点，遍历可能存在的子节点，往下递归;")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 模版编译")]),t._v("\ncompileElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 编译元素节点，拿到所有属性名称，进行遍历")]),t._v("\ncompileText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 编译文本节点")]),t._v("\n")])])]),s("img",{attrs:{src:a(386)}}),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("将生成的结果插入el;")])])])]),t._v(" "),s("h2",{attrs:{id:"模版编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模版编译"}},[t._v("#")]),t._v(" 模版编译")]),t._v(" "),s("p",[t._v("主要是在compile过程中：")]),t._v(" "),s("ul",[s("li",[t._v("parse函数解析template;")]),t._v(" "),s("li",[t._v("optimize函数优化静态内容；")]),t._v(" "),s("li",[t._v("generate函数创建render函数字符串，等待执行vdom时调用，进入patch流程，最终上DOM树；")])]),t._v(" "),s("ol",[s("li",[t._v("parse函数解析最终生成AST树：")])]),t._v(" "),s("p",[s("strong",[t._v("AST，在VUE中指的是一个嵌套的、有标签名、属性、父子关系等的JS对象，以树形来表示DOM结构。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("optimize优化：")])]),t._v(" "),s("p",[s("strong",[t._v("parse出来的AST进行标记静态节点、非静态节点的标记")])]),t._v(" "),s("p",[s("strong",[t._v("静态节点，指的是没有订阅state，不需要每次都刷新的标签")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("generate生成render函数：")])]),t._v(" "),s("p",[s("strong",[t._v("输入AST，返回AST，对AST进行递归，调用相应节点生成标签字符串的方法，返回生成字符串的render函数")])]),t._v(" "),s("img",{attrs:{src:a(387)}}),t._v(" "),s("h2",{attrs:{id:"patch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[t._v("#")]),t._v(" Patch")]),t._v(" "),s("p",[t._v("对比新旧的Vnode，创建、删除或者更新DOM节点/组件实例；使用Diff算法尽可能的复用先前的DOM节点；")]),t._v(" "),s("h2",{attrs:{id:"vue3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[t._v("#")]),t._v(" vue3")]),t._v(" "),s("p",[t._v("Vuejs3 在北京时间2020年9月19日凌晨，终于发布了3.0版本，代号：One Piece；")]),t._v(" "),s("p",[t._v("重要变更：")]),t._v(" "),s("ul",[s("li",[t._v("数据响应式使用proxy("),s("strong",[t._v("1")]),t._v(");")]),t._v(" "),s("li",[t._v("Tree-shaking support （尽量使用更有利于Tree-shaking的 export const/function 写法。"),s("strong",[t._v("4")]),t._v("）；")]),t._v(" "),s("li",[t._v("Composition API (setup入口，方便业务解耦合。"),s("strong",[t._v("2")]),t._v(")；")]),t._v(" "),s("li",[t._v("Fragment（支持多个根结点。"),s("strong",[t._v("5")]),t._v("）, Teleport（可以任意地丢到html中的任一个DOM下）, Suspense（控制异步组件）等新的玩法；")]),t._v(" "),s("li",[t._v("Better TypeScript support （更好的 TypeScript 支持度。"),s("strong",[t._v("3")]),t._v("）；")]),t._v(" "),s("li",[t._v("Custom Renderer API （自定义的 Renderer API createRenderer）；")]),t._v(" "),s("li",[t._v("解耦内部模块，例如可以单独使用reactivity（"),s("strong",[t._v("6")]),t._v("）")])]),t._v(" "),s("p",[t._v("性能上，有以下改进：")]),t._v(" "),s("ul",[s("li",[t._v("Rewritten virtual dom implementation （重写了虚拟 DOM）；")]),t._v(" "),s("li",[t._v("Compiler-informed fast paths （优化编译）；")]),t._v(" "),s("li",[t._v("virtual dom静态节点的hosting，真正的virtual node只包含动态节点；")]),t._v(" "),s("li",[t._v("More efficient component initialization （更高效的组件初始化）；")]),t._v(" "),s("li",[t._v("1.3-2x better update performance （1.3~2 倍的更新性能）；")]),t._v(" "),s("li",[t._v("2-3x faster SSR （2~3 倍的 SSR 速度）；")]),t._v(" "),s("li",[t._v("vite (构建工具)")])]),t._v(" "),s("p",[s("strong",[t._v("Oject.defineProperty的缺陷：")])]),t._v(" "),s("ol",[s("li",[t._v("无法监测到对象属性的添加和删除；")]),t._v(" "),s("li",[t._v("无法直接监听数组基于下标的变化，")]),t._v(" "),s("li",[t._v("vue2重写了push pop shift unshift splice sort reverse等会直接修改原数组的操作")])])])}),[],!1,null,null,null);e.default=r.exports}}]);